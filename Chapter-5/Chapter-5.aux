\relax 
\providecommand\zref@newlabel[2]{}
\providecommand\hyper@newdestlabel[2]{}
\@writefile{toc}{\contentsline {chapter}{\numberline {5}Code Architecture and Parallelization}{79}{chapter..5}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{chapter:architecture-parallelism}{{5}{79}{Code Architecture and Parallelization}{chapter..5}{}}
\@writefile{toc}{\contentsline {section}{\numberline {5.1}Introduction}{79}{section..5.1}}
\newlabel{sect:introduction}{{5.1}{79}{Introduction}{section..5.1}{}}
\citation{sagan2012space}
\@writefile{lof}{\contentsline {figure}{\numberline {5.1}{\ignorespaces Workflow for SPH code. Figure to the left is the basic workflow. The right figure is the workflow that enables dynamic halo domain. These steps in orange box are newly added steps. Extra computational costs associated with these extra steps are shown to be neglectable in section \ref  {sec:effect-of-halo-domain}}}{80}{figure..5.1}}
\newlabel{fig:Work_flow}{{5.1}{80}{Workflow for SPH code. Figure to the left is the basic workflow. The right figure is the workflow that enables dynamic halo domain. These steps in orange box are newly added steps. Extra computational costs associated with these extra steps are shown to be neglectable in section \ref {sec:effect-of-halo-domain}}{figure..5.1}{}}
\citation{patra1995problem}
\@writefile{lof}{\contentsline {figure}{\numberline {5.2}{\ignorespaces The left figure shows SFCs passing all particles and buckets. The right figure shows an example of a domain decomposition based on the SFC of buckets.}}{81}{figure..5.2}}
\newlabel{fig:SFC_domain_decomposition}{{5.2}{81}{The left figure shows SFCs passing all particles and buckets. The right figure shows an example of a domain decomposition based on the SFC of buckets}{figure..5.2}{}}
\@writefile{toc}{\contentsline {section}{\numberline {5.2}Data management and parallelization}{81}{section..5.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.2.1}SFC based indexing}{81}{subsection..5.2.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.2.2}Data management strategies}{83}{subsection..5.2.2}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {5.2.2.1}Particle and bucket}{83}{subsubsection..5.2.2.1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {5.2.2.2}Hash table and hash collision}{84}{subsubsection..5.2.2.2}}
\newlabel{eq:hash_function}{{5.3}{84}{Hash table and hash collision}{equation..5.2.3}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.3}{\ignorespaces Non-uniform distribution of particles in the $[0,1]^n \times \textbf  {T}$ space due to adding of new particles at a small area of the whole domain. Pointers to particles are managed by a hash table. External linked lists are attached to these slots with hash conflict.}}{85}{figure..5.3}}
\newlabel{fig:Particle_adding_with_link}{{5.3}{85}{Non-uniform distribution of particles in the $[0,1]^n \times \textbf {T}$ space due to adding of new particles at a small area of the whole domain. Pointers to particles are managed by a hash table. External linked lists are attached to these slots with hash conflict}{figure..5.3}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.2.3}Domain decomposition and load balancing strategy}{85}{subsection..5.2.3}}
\newlabel{sect:load_balance}{{5.2.3}{85}{Domain decomposition and load balancing strategy}{subsection..5.2.3}{}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {5.2.3.1}Calibrated particle workload}{85}{subsubsection..5.2.3.1}}
\newlabel{sec:Weighted_work_load}{{5.2.3.1}{85}{Calibrated particle workload}{subsubsection..5.2.3.1}{}}
\@writefile{lot}{\contentsline {table}{\numberline {5.1}{\ignorespaces Computational cost per particle for different steps}}{86}{table..5.1}}
\newlabel{tab:Computational_cost_steps}{{5.1}{86}{Computational cost per particle for different steps}{table..5.1}{}}
\newlabel{eq:work-load-bucket}{{5.4}{86}{Calibrated particle workload}{equation..5.2.4}{}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {5.2.3.2}Domain decomposition and dynamic load balancing}{86}{subsubsection..5.2.3.2}}
\newlabel{eq:work-load-balance}{{5.5}{86}{Domain decomposition and dynamic load balancing}{equation..5.2.5}{}}
\newlabel{eq:work-load-process}{{5.6}{87}{Domain decomposition and dynamic load balancing}{equation..5.2.6}{}}
\@writefile{toc}{\contentsline {section}{\numberline {5.3}Dynamic halo domain}{87}{section..5.3}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.4}{\ignorespaces The left figure shows strong scalability tests result. middle figure is the zoomed view of first one. It is obviously shown that strong scalability is better when the problem size is larger. The right figure is weak scalability test results}}{89}{figure..5.4}}
\newlabel{fig:2cases_efficiency}{{5.4}{89}{The left figure shows strong scalability tests result. middle figure is the zoomed view of first one. It is obviously shown that strong scalability is better when the problem size is larger. The right figure is weak scalability test results}{figure..5.4}{}}
\@writefile{toc}{\contentsline {section}{\numberline {5.4}Numerical test}{89}{section..5.4}}
\newlabel{sec:numerical-tests-computation}{{5.4}{89}{Numerical test}{section..5.4}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.4.1}Scalability test}{89}{subsection..5.4.1}}
\@writefile{lot}{\contentsline {table}{\numberline {5.2}{\ignorespaces Simulation time when using the same particle weight and different particle weights.}}{90}{table..5.2}}
\newlabel{tab:same_diff_particle_weight}{{5.2}{90}{Simulation time when using the same particle weight and different particle weights}{table..5.2}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.4.2}Effect of calibrated particle weights}{90}{subsection..5.4.2}}
\newlabel{sec:effect-of-calibrated-particle-weights}{{5.4.2}{90}{Effect of calibrated particle weights}{subsection..5.4.2}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.5}{\ignorespaces The influence of different load balance check intervals on simulation time. The bar values are the extra simulation time in log scale. The optimized interval is 3s.}}{91}{figure..5.5}}
\newlabel{fig:check_int}{{5.5}{91}{The influence of different load balance check intervals on simulation time. The bar values are the extra simulation time in log scale. The optimized interval is 3s}{figure..5.5}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.4.3}Effect of workload check interval}{91}{subsection..5.4.3}}
\newlabel{sec:effect-of-workload-check-interval}{{5.4.3}{91}{Effect of workload check interval}{subsection..5.4.3}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.4.4}Effect of dynamic halo domains}{91}{subsection..5.4.4}}
\newlabel{sec:effect-of-halo-domain}{{5.4.4}{91}{Effect of dynamic halo domains}{subsection..5.4.4}{}}
\@writefile{lot}{\contentsline {table}{\numberline {5.3}{\ignorespaces Computational workload of extra steps for domain adjusting. SWCH represents the step that switch pressure ghost particle to real particle, ADPP is short for adding new pressure ghost particles, ADWP represents adding wall ghost particles, SCN is short for scanning the outmost layer of the domain. Momentum and energy update (UPME) and position update (UPP) also included for comparison.}}{92}{table..5.3}}
\newlabel{tab:Computational_cost_doamin_adj}{{5.3}{92}{Computational workload of extra steps for domain adjusting. SWCH represents the step that switch pressure ghost particle to real particle, ADPP is short for adding new pressure ghost particles, ADWP represents adding wall ghost particles, SCN is short for scanning the outmost layer of the domain. Momentum and energy update (UPME) and position update (UPP) also included for comparison}{table..5.3}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.6}{\ignorespaces The figure on the top shows execution time without using the dynamic halo domain algorithm, the figure on the bottom shows execution time using the dynamic halo domain algorithm. Different bins represent execution time up to specific physical time indicated by horizontal axis.}}{92}{figure..5.6}}
\newlabel{fig:adj_vs_no}{{5.6}{92}{The figure on the top shows execution time without using the dynamic halo domain algorithm, the figure on the bottom shows execution time using the dynamic halo domain algorithm. Different bins represent execution time up to specific physical time indicated by horizontal axis}{figure..5.6}{}}
\citation{vacondio2012accurate,feldman2007dynamic}
\@writefile{toc}{\contentsline {section}{\numberline {5.5}Conclusion}{93}{section..5.5}}
\@setckpt{Chapter-5/Chapter-5}{
\setcounter{page}{94}
\setcounter{equation}{6}
\setcounter{enumi}{0}
\setcounter{enumii}{0}
\setcounter{enumiii}{0}
\setcounter{enumiv}{0}
\setcounter{footnote}{0}
\setcounter{mpfootnote}{0}
\setcounter{part}{0}
\setcounter{chapter}{5}
\setcounter{section}{5}
\setcounter{subsection}{0}
\setcounter{subsubsection}{0}
\setcounter{paragraph}{0}
\setcounter{subparagraph}{0}
\setcounter{figure}{6}
\setcounter{table}{3}
\setcounter{lofdepth}{1}
\setcounter{lotdepth}{1}
\setcounter{parentequation}{0}
\setcounter{NAT@ctr}{0}
\setcounter{LT@tables}{0}
\setcounter{LT@chunks}{0}
\setcounter{Item}{0}
\setcounter{Hfootnote}{0}
\setcounter{bookmark@seq@number}{0}
\setcounter{section@level}{1}
}
